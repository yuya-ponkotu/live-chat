{"ast":null,"code":"// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue';\nimport { convertToUnit, getScrollParent, IN_BROWSER, isFixedPosition, nullifyTransforms, propsFactory } from \"../../util/index.mjs\";\nimport { oppositeAnchor, parseAnchor, physicalAnchor } from \"./util/anchor.mjs\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\"; // Types\n\nimport { Box } from \"../../util/box.mjs\";\nconst positionStrategies = {\n  static: staticPositionStrategy,\n  // specific viewport position, usually centered\n  connected: connectedPositionStrategy // connected to a certain element\n\n};\nexport const makePositionStrategyProps = propsFactory({\n  positionStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in positionStrategies\n  },\n  anchor: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String]\n});\nexport function usePositionStrategies(props, data) {\n  const contentStyles = ref({});\n  const updatePosition = ref();\n  let scope;\n  watchEffect(async () => {\n    var _scope;\n\n    (_scope = scope) == null ? void 0 : _scope.stop();\n    updatePosition.value = undefined;\n    if (!(IN_BROWSER && data.isActive.value && props.positionStrategy)) return;\n    scope = effectScope();\n    await nextTick();\n    scope.run(() => {\n      if (typeof props.positionStrategy === 'function') {\n        var _props$positionStrate;\n\n        updatePosition.value = (_props$positionStrate = props.positionStrategy(data, props, contentStyles)) == null ? void 0 : _props$positionStrate.updatePosition;\n      } else {\n        var _positionStrategies$p;\n\n        updatePosition.value = (_positionStrategies$p = positionStrategies[props.positionStrategy](data, props, contentStyles)) == null ? void 0 : _positionStrategies$p.updatePosition;\n      }\n    });\n  });\n  IN_BROWSER && window.addEventListener('resize', onResize, {\n    passive: true\n  });\n  onScopeDispose(() => {\n    var _scope2;\n\n    IN_BROWSER && window.removeEventListener('resize', onResize);\n    updatePosition.value = undefined;\n    (_scope2 = scope) == null ? void 0 : _scope2.stop();\n  });\n\n  function onResize(e) {\n    var _updatePosition$value;\n\n    (_updatePosition$value = updatePosition.value) == null ? void 0 : _updatePosition$value.call(updatePosition, e);\n  }\n\n  return {\n    contentStyles,\n    updatePosition\n  };\n}\n\nfunction staticPositionStrategy() {// TODO\n}\n\nfunction connectedPositionStrategy(data, props, contentStyles) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value);\n\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed'\n    });\n  }\n\n  const preferredAnchor = computed(() => parseAnchor(props.anchor));\n  const preferredOrigin = computed(() => props.origin === 'overlap' ? preferredAnchor.value : props.origin === 'auto' ? oppositeAnchor(preferredAnchor.value) : parseAnchor(props.origin));\n  const doesOverlap = computed(() => {\n    return preferredAnchor.value.side === preferredOrigin.value.side;\n  });\n  const configuredMaxHeight = computed(() => {\n    const val = parseFloat(props.maxHeight);\n    return isNaN(val) ? Infinity : val;\n  });\n  const configuredMinWidth = computed(() => {\n    const val = parseFloat(props.minWidth);\n    return isNaN(val) ? Infinity : val;\n  });\n  let observe = false;\n\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updatePosition();\n    });\n    observer.observe(data.activatorEl.value);\n    observer.observe(data.contentEl.value);\n    onScopeDispose(() => {\n      observer.disconnect();\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  function updatePosition() {\n    var _props$maxWidth;\n\n    observe = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true);\n    });\n    const targetBox = data.activatorEl.value.getBoundingClientRect(); // TODO: offset shouldn't affect width\n\n    if (props.offset) {\n      targetBox.x -= +props.offset;\n      targetBox.y -= +props.offset;\n      targetBox.width += +props.offset * 2;\n      targetBox.height += +props.offset * 2;\n    }\n\n    const scrollParent = getScrollParent(data.contentEl.value);\n    const viewportWidth = scrollParent.clientWidth;\n    const viewportHeight = Math.min(scrollParent.clientHeight, window.innerHeight);\n    let contentBox;\n    {\n      const scrollables = new Map();\n      data.contentEl.value.querySelectorAll('*').forEach(el => {\n        const x = el.scrollLeft;\n        const y = el.scrollTop;\n\n        if (x || y) {\n          scrollables.set(el, [x, y]);\n        }\n      });\n      const initialMaxWidth = data.contentEl.value.style.maxWidth;\n      const initialMaxHeight = data.contentEl.value.style.maxHeight;\n      data.contentEl.value.style.removeProperty('max-width');\n      data.contentEl.value.style.removeProperty('max-height');\n      contentBox = nullifyTransforms(data.contentEl.value);\n      contentBox.x -= parseFloat(data.contentEl.value.style.left) || 0;\n      contentBox.y -= parseFloat(data.contentEl.value.style.top) || 0;\n      data.contentEl.value.style.maxWidth = initialMaxWidth;\n      data.contentEl.value.style.maxHeight = initialMaxHeight;\n      scrollables.forEach((position, el) => {\n        el.scrollTo(...position);\n      });\n    }\n    const contentHeight = Math.min(configuredMaxHeight.value, contentBox.height); // Regard undefined maxWidth as maximally occupying whole remaining space by default\n\n    const maxFreeSpaceWidth = props.maxWidth === undefined ? Number.MAX_VALUE : parseInt((_props$maxWidth = props.maxWidth) != null ? _props$maxWidth : 0, 10);\n    const viewportMargin = 12;\n    const freeSpace = {\n      top: targetBox.top - viewportMargin,\n      bottom: viewportHeight - targetBox.bottom - viewportMargin,\n      left: Math.min(targetBox.left - viewportMargin, maxFreeSpaceWidth),\n      right: Math.min(viewportWidth - targetBox.right - viewportMargin, maxFreeSpaceWidth)\n    };\n    const fitsY = preferredAnchor.value.side === 'bottom' && contentHeight <= freeSpace.bottom || preferredAnchor.value.side === 'top' && contentHeight <= freeSpace.top;\n    const anchor = fitsY ? preferredAnchor.value : preferredAnchor.value.side === 'bottom' && freeSpace.top > freeSpace.bottom || preferredAnchor.value.side === 'top' && freeSpace.bottom > freeSpace.top ? oppositeAnchor(preferredAnchor.value) : preferredAnchor.value;\n    const origin = fitsY ? preferredOrigin.value : oppositeAnchor(anchor);\n    const canFill = doesOverlap.value || ['center', 'top', 'bottom'].includes(anchor.side);\n    const maxWidth = canFill ? Math.min(viewportWidth, Math.max(targetBox.width, viewportWidth - viewportMargin * 2)) : anchor.side === 'end' ? freeSpace.right : anchor.side === 'start' ? freeSpace.left : null;\n    const minWidth = Math.min(configuredMinWidth.value, maxWidth, targetBox.width);\n    const maxHeight = fitsY ? configuredMaxHeight.value : Math.min(configuredMaxHeight.value, Math.floor(anchor.side === 'top' ? freeSpace.top : freeSpace.bottom));\n    const targetPoint = anchorToPoint(anchor, targetBox);\n    const contentPoint = anchorToPoint(origin, new Box({ ...contentBox,\n      height: Math.min(contentHeight, maxHeight)\n    }));\n    const {\n      x,\n      y\n    } = getOffset(targetPoint, contentPoint);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': physicalAnchor(anchor, data.activatorEl.value),\n      top: convertToUnit(Math.round(y)),\n      left: convertToUnit(Math.round(x)),\n      // TODO: right for origin=\"end\", rtl\n      transformOrigin: physicalAnchor(origin, data.activatorEl.value),\n      minWidth: convertToUnit(minWidth),\n      maxWidth: convertToUnit(maxWidth),\n      maxHeight: convertToUnit(maxHeight)\n    });\n  }\n\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset], () => updatePosition(), {\n    immediate: !activatorFixed\n  });\n  if (activatorFixed) nextTick(() => updatePosition());\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updatePosition();\n  });\n  return {\n    updatePosition\n  };\n}","map":{"version":3,"mappings":"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","names":["computed","effectScope","nextTick","onScopeDispose","ref","watch","watchEffect","convertToUnit","getScrollParent","IN_BROWSER","isFixedPosition","nullifyTransforms","propsFactory","oppositeAnchor","parseAnchor","physicalAnchor","anchorToPoint","getOffset","Box","positionStrategies","static","staticPositionStrategy","connected","connectedPositionStrategy","makePositionStrategyProps","positionStrategy","type","String","Function","default","validator","val","anchor","origin","offset","Number","usePositionStrategies","props","data","contentStyles","updatePosition","scope","stop","value","undefined","isActive","run","_props$positionStrate","_positionStrategies$p","window","addEventListener","onResize","passive","removeEventListener","e","activatorFixed","activatorEl","Object","assign","position","preferredAnchor","preferredOrigin","doesOverlap","side","configuredMaxHeight","parseFloat","maxHeight","isNaN","Infinity","configuredMinWidth","minWidth","observe","observer","ResizeObserver","contentEl","disconnect","requestAnimationFrame","targetBox","getBoundingClientRect","x","y","width","height","scrollParent","viewportWidth","clientWidth","viewportHeight","Math","min","clientHeight","innerHeight","contentBox","scrollables","Map","querySelectorAll","forEach","el","scrollLeft","scrollTop","set","initialMaxWidth","style","maxWidth","initialMaxHeight","removeProperty","left","top","scrollTo","contentHeight","maxFreeSpaceWidth","MAX_VALUE","parseInt","viewportMargin","freeSpace","bottom","right","fitsY","canFill","includes","max","floor","targetPoint","contentPoint","round","transformOrigin","immediate"],"sources":["../../../src/components/VOverlay/positionStrategies.ts"],"sourcesContent":["// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue'\nimport { convertToUnit, getScrollParent, IN_BROWSER, isFixedPosition, nullifyTransforms, propsFactory } from '@/util'\nimport { oppositeAnchor, parseAnchor, physicalAnchor } from './util/anchor'\nimport { anchorToPoint, getOffset } from './util/point'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\nimport type { Anchor } from './util/anchor'\nimport { Box } from '@/util/box'\n\nexport interface PositionStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n}\n\nconst positionStrategies = {\n  static: staticPositionStrategy, // specific viewport position, usually centered\n  connected: connectedPositionStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  positionStrategy: keyof typeof positionStrategies | (\n    (\n      data: PositionStrategyData,\n      props: StrategyProps,\n      contentStyles: Ref<Record<string, string>>\n    ) => undefined | { updatePosition: (e: Event) => void }\n  )\n  anchor: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makePositionStrategyProps = propsFactory({\n  positionStrategy: {\n    type: [String, Function] as PropType<StrategyProps['positionStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in positionStrategies,\n  },\n  anchor: {\n    type: String as PropType<StrategyProps['anchor']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String],\n})\n\nexport function usePositionStrategies (\n  props: StrategyProps,\n  data: PositionStrategyData\n) {\n  const contentStyles = ref({})\n  const updatePosition = ref<(e: Event) => void>()\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n    updatePosition.value = undefined\n\n    if (!(IN_BROWSER && data.isActive.value && props.positionStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.run(() => {\n      if (typeof props.positionStrategy === 'function') {\n        updatePosition.value = props.positionStrategy(data, props, contentStyles)?.updatePosition\n      } else {\n        updatePosition.value = positionStrategies[props.positionStrategy](data, props, contentStyles)?.updatePosition\n      }\n    })\n  })\n\n  IN_BROWSER && window.addEventListener('resize', onResize, { passive: true })\n\n  onScopeDispose(() => {\n    IN_BROWSER && window.removeEventListener('resize', onResize)\n    updatePosition.value = undefined\n    scope?.stop()\n  })\n\n  function onResize (e: Event) {\n    updatePosition.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updatePosition,\n  }\n}\n\nfunction staticPositionStrategy () {\n  // TODO\n}\n\nfunction connectedPositionStrategy (data: PositionStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n    })\n  }\n\n  const preferredAnchor = computed(() => parseAnchor(props.anchor))\n  const preferredOrigin = computed(() =>\n    props.origin === 'overlap' ? preferredAnchor.value\n    : props.origin === 'auto' ? oppositeAnchor(preferredAnchor.value)\n    : parseAnchor(props.origin)\n  )\n  const doesOverlap = computed(() => {\n    return preferredAnchor.value.side === preferredOrigin.value.side\n  })\n\n  const configuredMaxHeight = computed(() => {\n    const val = parseFloat(props.maxHeight!)\n    return isNaN(val) ? Infinity : val\n  })\n\n  const configuredMinWidth = computed(() => {\n    const val = parseFloat(props.minWidth!)\n    return isNaN(val) ? Infinity : val\n  })\n\n  let observe = false\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updatePosition()\n    })\n    observer.observe(data.activatorEl.value!)\n    observer.observe(data.contentEl.value!)\n\n    onScopeDispose(() => {\n      observer.disconnect()\n    })\n  }\n\n  // eslint-disable-next-line max-statements\n  function updatePosition () {\n    observe = false\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true)\n    })\n\n    const targetBox = data.activatorEl.value!.getBoundingClientRect()\n    // TODO: offset shouldn't affect width\n    if (props.offset) {\n      targetBox.x -= +props.offset\n      targetBox.y -= +props.offset\n      targetBox.width += +props.offset * 2\n      targetBox.height += +props.offset * 2\n    }\n\n    const scrollParent = getScrollParent(data.contentEl.value)\n    const viewportWidth = scrollParent.clientWidth\n    const viewportHeight = Math.min(scrollParent.clientHeight, window.innerHeight)\n\n    let contentBox\n    {\n      const scrollables = new Map<Element, [number, number]>()\n      data.contentEl.value!.querySelectorAll('*').forEach(el => {\n        const x = el.scrollLeft\n        const y = el.scrollTop\n        if (x || y) {\n          scrollables.set(el, [x, y])\n        }\n      })\n\n      const initialMaxWidth = data.contentEl.value!.style.maxWidth\n      const initialMaxHeight = data.contentEl.value!.style.maxHeight\n      data.contentEl.value!.style.removeProperty('max-width')\n      data.contentEl.value!.style.removeProperty('max-height')\n\n      contentBox = nullifyTransforms(data.contentEl.value!)\n      contentBox.x -= parseFloat(data.contentEl.value!.style.left) || 0\n      contentBox.y -= parseFloat(data.contentEl.value!.style.top) || 0\n\n      data.contentEl.value!.style.maxWidth = initialMaxWidth\n      data.contentEl.value!.style.maxHeight = initialMaxHeight\n      scrollables.forEach((position, el) => {\n        el.scrollTo(...position)\n      })\n    }\n\n    const contentHeight = Math.min(configuredMaxHeight.value, contentBox.height)\n\n    // Regard undefined maxWidth as maximally occupying whole remaining space by default\n    const maxFreeSpaceWidth = props.maxWidth === undefined ? Number.MAX_VALUE : parseInt(props.maxWidth ?? 0, 10)\n\n    const viewportMargin = 12\n    const freeSpace = {\n      top: targetBox.top - viewportMargin,\n      bottom: viewportHeight - targetBox.bottom - viewportMargin,\n      left: Math.min(targetBox.left - viewportMargin, maxFreeSpaceWidth),\n      right: Math.min(viewportWidth - targetBox.right - viewportMargin, maxFreeSpaceWidth),\n    }\n\n    const fitsY = (preferredAnchor.value.side === 'bottom' && contentHeight <= freeSpace.bottom) ||\n      (preferredAnchor.value.side === 'top' && contentHeight <= freeSpace.top)\n\n    const anchor = fitsY ? preferredAnchor.value\n      : (preferredAnchor.value.side === 'bottom' && freeSpace.top > freeSpace.bottom) ||\n      (preferredAnchor.value.side === 'top' && freeSpace.bottom > freeSpace.top) ? oppositeAnchor(preferredAnchor.value)\n      : preferredAnchor.value\n    const origin = fitsY ? preferredOrigin.value : oppositeAnchor(anchor)\n\n    const canFill = doesOverlap.value || ['center', 'top', 'bottom'].includes(anchor.side)\n\n    const maxWidth = canFill ? Math.min(viewportWidth, Math.max(targetBox.width, viewportWidth - viewportMargin * 2))\n      : anchor.side === 'end' ? freeSpace.right\n      : anchor.side === 'start' ? freeSpace.left\n      : null\n    const minWidth = Math.min(configuredMinWidth.value, maxWidth!, targetBox.width)\n    const maxHeight = fitsY ? configuredMaxHeight.value : Math.min(\n      configuredMaxHeight.value,\n      Math.floor(anchor.side === 'top' ? freeSpace.top : freeSpace.bottom)\n    )\n\n    const targetPoint = anchorToPoint(anchor, targetBox)\n    const contentPoint = anchorToPoint(origin, new Box({\n      ...contentBox,\n      height: Math.min(contentHeight, maxHeight),\n    }))\n\n    const { x, y } = getOffset(targetPoint, contentPoint)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': physicalAnchor(anchor, data.activatorEl.value!),\n      top: convertToUnit(Math.round(y)),\n      left: convertToUnit(Math.round(x)), // TODO: right for origin=\"end\", rtl\n      transformOrigin: physicalAnchor(origin, data.activatorEl.value!),\n      minWidth: convertToUnit(minWidth),\n      maxWidth: convertToUnit(maxWidth),\n      maxHeight: convertToUnit(maxHeight),\n    })\n  }\n\n  watch(\n    () => [preferredAnchor.value, preferredOrigin.value, props.offset],\n    () => updatePosition(),\n    { immediate: !activatorFixed }\n  )\n\n  if (activatorFixed) nextTick(() => updatePosition())\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updatePosition()\n  })\n\n  return { updatePosition }\n}\n"]},"metadata":{},"sourceType":"module"}