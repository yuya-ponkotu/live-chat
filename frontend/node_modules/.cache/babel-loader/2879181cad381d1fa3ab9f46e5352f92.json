{"ast":null,"code":"const block = ['top', 'bottom'];\nconst inline = ['start', 'end'];\n/** Parse a raw anchor string into an object */\n\nexport function parseAnchor(anchor) {\n  let [side, align] = anchor.split(' ');\n\n  if (!align) {\n    align = side === 'top' || side === 'bottom' ? 'start' : side === 'start' || side === 'end' ? 'top' : 'center';\n  }\n\n  return {\n    side,\n    align\n  };\n}\n/** Get an anchor directly opposite, with the same alignment */\n\nexport function oppositeAnchor(anchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start'\n    }[anchor.side],\n    align: anchor.align\n  };\n}\n/** Convert start/end into left/right */\n\nexport function physicalAnchor(anchor, el) {\n  var _map$side, _map$align;\n\n  const {\n    side,\n    align\n  } = anchor;\n  const {\n    direction\n  } = window.getComputedStyle(el);\n  const map = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right'\n  } : {\n    start: 'right',\n    end: 'left'\n  };\n  return ((_map$side = map[side]) != null ? _map$side : side) + ' ' + ((_map$align = map[align]) != null ? _map$align : align);\n}","map":{"version":3,"mappings":"AAAA,MAAMA,KAAK,GAAG,CAAC,KAAD,EAAQ,QAAR,CAAd;AACA,MAAMC,MAAM,GAAG,CAAC,OAAD,EAAU,KAAV,CAAf;AAeA;;AACA,OAAO,SAASC,WAAT,CAAsBC,MAAtB,EAAsC;AAC3C,MAAI,CAACC,IAAD,EAAOC,KAAP,IAAgBF,MAAM,CAACG,KAAPH,CAAa,GAAbA,CAApB;;AACA,MAAI,CAACE,KAAL,EAAY;AACVA,SAAK,GACHD,IAAI,KAAK,KAATA,IAAkBA,IAAI,KAAK,QAA3BA,GAAsC,OAAtCA,GACEA,IAAI,KAAK,OAATA,IAAoBA,IAAI,KAAK,KAA7BA,GAAqC,KAArCA,GACA,QAHJC;AAID;;AACD,SAAO;AACLD,QADK;AAELC;AAFK,GAAP;AAID;AAED;;AACA,OAAO,SAASE,cAAT,CAAyBJ,MAAzB,EAA+C;AACpD,SAAO;AACLC,QAAI,EAAE;AACJI,YAAM,EAAE,QADJ;AAEJC,SAAG,EAAE,QAFD;AAGJC,YAAM,EAAE,KAHJ;AAIJC,WAAK,EAAE,KAJH;AAKJC,SAAG,EAAE;AALD,MAMJT,MAAM,CAACC,IANH,CADD;AAQLC,SAAK,EAAEF,MAAM,CAACE;AART,GAAP;AAUD;AAED;;AACA,OAAO,SAASQ,cAAT,CAAyBV,MAAzB,EAA+CW,EAA/C,EAAgE;AAAA;;AACrE,QAAM;AAAEV,QAAF;AAAQC;AAAR,MAAkBF,MAAxB;AACA,QAAM;AAAEY;AAAF,MAAgBC,MAAM,CAACC,gBAAPD,CAAwBF,EAAxBE,CAAtB;AAEA,QAAME,GAAuC,GAAGH,SAAS,KAAK,KAAdA,GAAsB;AACpEJ,SAAK,EAAE,MAD6D;AAEpEC,OAAG,EAAE;AAF+D,GAAtBG,GAG5C;AACFJ,SAAK,EAAE,OADL;AAEFC,OAAG,EAAE;AAFH,GAHJ;AAQA,SAAO,cAACM,GAAG,CAACd,IAAD,CAAJ,wBAAcA,IAAd,IAAsB,GAAtB,kBAA6Bc,GAAG,CAACb,KAAD,CAAhC,yBAA2CA,KAA3C,CAAP;AACD","names":["block","inline","parseAnchor","anchor","side","align","split","oppositeAnchor","center","top","bottom","start","end","physicalAnchor","el","direction","window","getComputedStyle","map"],"sources":["../../../../src/components/VOverlay/util/anchor.ts"],"sourcesContent":["const block = ['top', 'bottom'] as const\nconst inline = ['start', 'end'] as const\ntype Tblock = typeof block[number]\ntype Tinline = typeof inline [number]\nexport type Anchor =\n  | Tblock\n  | Tinline\n  | 'center'\n  | 'center center'\n  | `${Tblock} ${Tinline | 'center'}`\n  | `${Tinline} ${Tblock | 'center'}`\nexport type ParsedAnchor =\n  | { side: 'center', align: 'center' }\n  | { side: Tblock, align: Tinline | 'center' }\n  | { side: Tinline, align: Tblock | 'center' }\n\n/** Parse a raw anchor string into an object */\nexport function parseAnchor (anchor: Anchor) {\n  let [side, align] = anchor.split(' ')\n  if (!align) {\n    align =\n      side === 'top' || side === 'bottom' ? 'start'\n      : side === 'start' || side === 'end' ? 'top'\n      : 'center'\n  }\n  return {\n    side,\n    align,\n  } as ParsedAnchor\n}\n\n/** Get an anchor directly opposite, with the same alignment */\nexport function oppositeAnchor (anchor: ParsedAnchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start',\n    }[anchor.side],\n    align: anchor.align,\n  } as ParsedAnchor\n}\n\n/** Convert start/end into left/right */\nexport function physicalAnchor (anchor: ParsedAnchor, el: HTMLElement) {\n  const { side, align } = anchor\n  const { direction } = window.getComputedStyle(el)\n\n  const map: Record<string, string | undefined> = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right',\n  } : {\n    start: 'right',\n    end: 'left',\n  }\n\n  return (map[side] ?? side) + ' ' + (map[align] ?? align)\n}\n"]},"metadata":{},"sourceType":"module"}